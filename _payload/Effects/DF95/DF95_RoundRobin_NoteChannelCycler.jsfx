desc:DF95 RoundRobin Note Channel Cycler
// @version 1.1
// @author DF95
// @about
//   MIDI-Effekt für RoundRobin mit ReaSamplomatic5000-basierten Kits.
//   Annahme:
//     - Pro Instrument existieren mehrere RS5k-Instanzen auf derselben Note,
//       aber mit UNTERSCHIEDLICHEN MIDI-Kanälen (z.B. Kanal 1, 2, 3, 4).
//     - Dieses Plugin nimmt eingehende Note-On/Off auf einem Basis-Kanal
//       entgegen (z.B. Kanal 1) und verteilt sie auf die Kanäle 1..N_VARIANTS.
//   Verwendung:
//     1. RoundRobin-Kit mit DF95_Sampler_Build_RoundRobin_Kit.lua bauen,
//        so dass pro Layer ein anderer MIDI-Kanal gesetzt ist.
//     2. Dieses JSFX VOR der RS5k-Kette auf der Spur einfügen.
//     3. In den Slidern Anzahl Variationen, Eingangs-Kanal & Mode einstellen.
//
//   Hinweis:
//     - Die Zuweisung erfolgt pro Note-Pitch (d.h. jede Note hat ihren
//       eigenen Zähler).
//     - Mode 0 = Cycle: deterministische Reihenfolge 1 -> 2 -> ... -> N -> 1.
//     - Mode 1 = Random: zufällige Auswahl, optional "No immediate repeat".

slider1:4<1,8,1>Varianten (Layers) pro Instrument
slider2:1<1,16,1>Eingangs-MIDI-Kanal
slider3:0<0,1,1{Cycle,Random}>Mode
slider4:1<0,1,1>No immediate repeat (Random)

@init
  variants = max(1, slider1|0);
  in_chan  = max(1, slider2|0);
  mode     = slider3|0;
  no_repeat = slider4|0;

  i = 0;
  loop(128,
    rr_idx[i] = 0;    // Last-used index per note
    last_idx[i] = 0;  // For random no-repeat
    i += 1;
  );

@slider
  variants  = max(1, slider1|0);
  in_chan   = max(1, slider2|0);
  mode      = slider3|0;
  no_repeat = slider4|0;

@block
  while (
    midirecv(offset, msg1, msg2, msg3) ? (
      status = msg1 & 0xF0;
      chan   = (msg1 & 0x0F) + 1; // 1..16
      note   = msg2;

      is_note = (status == 0x90 || status == 0x80);
      is_on   = (status == 0x90 && msg3 > 0);
      is_off  = (status == 0x80 || (status == 0x90 && msg3 == 0));

      new_chan = chan;

      is_note && chan == in_chan ? (
        idx = rr_idx[note];

        mode == 0 ? (
          // Cycle
          is_on ? (
            idx += 1;
            idx > variants ? idx = 1;
            rr_idx[note] = idx;
          );
        ) : (
          // Random
          is_on ? (
            // random index 1..variants, ggf. ohne direkten Repeat
            idx = floor(rand(variants)) + 1;
            no_repeat && variants > 1 ? (
              idx == last_idx[note] ? (
                // einfach noch ein zweites Mal versuchen
                idx = floor(rand(variants)) + 1;
                idx == last_idx[note] ? (
                  // wenn immer noch gleich, akzeptieren wir es
                  idx;
                );
              );
            );
            rr_idx[note] = idx;
            last_idx[note] = idx;
          );
        );

        // Note-Off muss denselben Layer treffen -> denselben Index verwenden
        !is_on ? (
          idx = rr_idx[note];
          idx < 1 ? idx = 1;
        );

        new_chan = max(1, min(variants, idx));

        msg1 = (status | (new_chan-1));
      );

      midisend(offset, msg1, msg2, msg3);
    );
  );
